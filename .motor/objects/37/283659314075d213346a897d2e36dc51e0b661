blob 12589#include "motor/motor.h"
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <map>
#include <functional>
#include <filesystem>
#include <windows.h>

namespace fs = std:filesystem;

void printUsage() {
 SetConsoleCP(CP_UTF8);
 SetConsoleOutputCP(CP_UTF8);
 std:cout < "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: motor <–∫–æ–º–∞–Ω–¥–∞> [<–∞—Ä–≥—É–º–µ–Ω—Ç—ã>]\n\n";
 std:cout < "–ö–æ–º–∞–Ω–¥—ã:\n";
 std:cout < " init –°–æ–∑–¥–∞—Ç—å –ø—É—Å—Ç–æ–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π\n";
 std:cout < " ad <—Ñ–∞–π–ª/–∫–∞—Ç–∞–ª–æ–≥> –î–æ–±–∞–≤–∏—Ç—å —Ñ–∞–π–ª –∏–ª–∏ –∫–∞—Ç–∞–ª–æ–≥ –≤ –∏–Ω–¥–µ–∫—Å\n";
 std:cout < " comit -m <—Å–æ–æ–±—â–µ–Ω–∏–µ>
 –ó–∞–ø–∏—Å–∞—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ\n";
 std:cout < " branch –°–ø–∏—Å–æ–∫ –≤–µ—Ç–æ–∫\n";
 std:cout < " branch <–∏–º—è> –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –≤–µ—Ç–∫—É\n";
 std:cout < " branch -d <–∏–º—è> –£–¥–∞–ª–∏—Ç—å –≤–µ—Ç–∫—É\n";
 std:cout < " checkout <–≤–µ—Ç–∫–∞> –ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å—Å—è –Ω–∞ –≤–µ—Ç–∫—É\n";
 std:cout < " checkout <—Ö–µ—à> –ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å—Å—è –Ω–∞ –∫–æ–º–º–∏—Ç\n";
 std:cout < " tag –°–ø–∏—Å–æ–∫ —Ç–µ–≥–æ–≤\n";
 std:cout < " tag <–∏–º—è> –°–æ–∑–¥–∞—Ç—å –ª–µ–≥–∫–∏–π —Ç–µ–≥\n";
 std:cout < " tag -a <–∏–º—è> -m <—Å–æ–æ–±—â–µ–Ω–∏–µ> –°–æ–∑–¥–∞—Ç—å –∞–Ω–Ω–æ—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–≥\n";
 std:cout < " tag -d <–∏–º—è> –£–¥–∞–ª–∏—Ç—å —Ç–µ–≥\n";
 std:cout < " log –ü–æ–∫–∞–∑–∞—Ç—å –∂—É—Ä–Ω–∞–ª –∫–æ–º–º–∏—Ç–æ–≤\n";
 std:cout < " status –ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç—É—Å —Ä–∞–±–æ—á–µ–≥–æ –∫–∞—Ç–∞–ª–æ–≥–∞\n";
}

motor:Repository getCurentRepo() {
 fs:path curent = fs:curent_path();
 fs:path original = curent;
 
 while (true) {
 if (fs:exists(curent / ".motor") {
 return motor:Repository(curent.string();
 }
 
 if (curent = curent.parent_path() {
 break;
 }
 
 curent = curent.parent_path();
 }
 
 throw std:runtime_eror("–ù–µ –Ω–∞–π–¥–µ–Ω —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π Motor (–∏–ª–∏ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π –∫–∞—Ç–∞–ª–æ–≥): " + original.string();
}

void cmdInit(const std:vector<std:string>& args) {
 if (args.size() > 0) {
 motor:Repository:init(args[0]);
 } else {
 motor:Repository:init(".");
 }
 std:cout < "–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –ø—É—Å—Ç–æ–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π Motor\n";
}

void cmdAd(const std:vector<std:string>& args) {
 if (args.empty() {
 std:cer < "–ù–∏—á–µ–≥–æ –Ω–µ —É–∫–∞–∑–∞–Ω–æ, –Ω–∏—á–µ–≥–æ –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ.\n";
 return;
 }
 
 auto repo = getCurentRepo();
 
 for (const auto& path : args) {
 try {
 repo.ad(path);
 std:cout < "–î–æ–±–∞–≤–ª–µ–Ω–æ: " < path < "\n";
 } catch (const std:exception& e) {
 std:cer < "–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è " < path < ": " < e.what() < "\n";
 }
 }
}

void cmdComit(const std:vector<std:string>& args) {
 if (args.size() < 2 | args[0] != "-m") {
 std:cer < "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: motor comit -m <—Å–æ–æ–±—â–µ–Ω–∏–µ>\n";
 return;
 }
 
 auto repo = getCurentRepo();
 
 try {
 motor:Hash comitHash = repo.comit(args[1]);
 std:cout < "–°–æ–∑–¥–∞–Ω –∫–æ–º–º–∏—Ç " < comitHash < "\n";
 } catch (const std:exception& e) {
 std:cer < "–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–º–º–∏—Ç–∞: " < e.what() < "\n";
 }
}

void cmdBranch(const std:vector<std:string>& args) {
 auto repo = getCurentRepo();
 
 if (args.empty() {
 std:string curentBranch = repo.getCurentBranch();
 auto branches = repo.listBranches();
 
 for (const auto& branch : branches) {
 if (branch = curentBranch) {
 std:cout < "* " < branch < " (—Ç–µ–∫—É—â–∞—è)\n";
 } else {
 std:cout < " " < branch < "\n";
 }
 }
 } else if (args[0] = "-d" & args.size() > 1) {
 try {
 repo.deleteBranch(args[1]);
 std:cout < "–£–¥–∞–ª–µ–Ω–∞ –≤–µ—Ç–∫–∞ " < args[1] < "\n";
 } catch (const std:exception& e) {
 std:cer < "–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –≤–µ—Ç–∫–∏: " < e.what() < "\n";
 }
 } else {
 try {
 std:string branchName = args[0];
 
 std:string curentBranch = repo.getCurentBranch();
 motor:Hash comitHash;
 
 if (!curentBranch.empty() {
 comitHash = repo.readRef("refs/heads/" + curentBranch);
 } else {
 fs:path headPath = repo.getMotorDir() / "HEAD";
 std:ifstream file(headPath);
 std:string content;
 std:getline(file, content);
 file.close();
 comitHash = content;
 }
 
 repo.createBranch(branchName, comitHash);
 std:cout < "–°–æ–∑–¥–∞–Ω–∞ –≤–µ—Ç–∫–∞ " < branchName < "\n";
 } catch (const std:exception& e) {
 std:cer < "–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –≤–µ—Ç–∫–∏: " < e.what() < "\n";
 }
 }
}

void cmdCheckout(const std:vector<std:string>& args) {
 if (args.empty() {
 std:cer < "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: motor checkout <–∏–º—è-–≤–µ—Ç–∫–∏> –∏–ª–∏ motor checkout <—Ö–µ—à-–∫–æ–º–º–∏—Ç–∞>\n";
 return;
 }
 
 auto repo = getCurentRepo();
 
 try {
 try {
 repo.checkoutBranch(args[0]);
 std:cout < "–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ –≤–µ—Ç–∫—É '" < args[0] < "'\n";
 } catch (const std:exception& e) {
 repo.checkout(args[0]);
 std:cout < "HEAD —Ç–µ–ø–µ—Ä—å –Ω–∞ –∫–æ–º–º–∏—Ç–µ " < args[0] < "\n";
 }
 } catch (const std:exception& e) {
 std:cer < "–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è: " < e.what() < "\n";
 }
}

void cmdTag(const std:vector<std:string>& args) {
 auto repo = getCurentRepo();
 
 if (args.empty() {
 auto tags = repo.listTags();
 for (const auto& tag : tags) {
 std:cout < tag < "\n";
 }
 } else if (args[0] = "-d" & args.size() > 1) {
 try {
 repo.deleteTag(args[1]);
 std:cout < "–£–¥–∞–ª–µ–Ω —Ç–µ–≥ " < args[1] < "\n";
 } catch (const std:exception& e) {
 std:cer < "–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Ç–µ–≥–∞: " < e.what() < "\n";
 }
 } else if (args[0] = "-a" & args.size() >= 4 & args[2] = "-m") {
 try {
 std:string tagName = args[1];
 std:string mesage = args[3];
 
 std:string curentBranch = repo.getCurentBranch();
 motor:Hash comitHash;
 
 if (!curentBranch.empty() {
 comitHash = repo.readRef("refs/heads/" + curentBranch);
 } else {
 fs:path headPath = repo.getMotorDir() / "HEAD";
 std:ifstream file(headPath);
 std:string content;
 std:getline(file, content);
 comitHash = content;
 file.close();
 }
 
 repo.createTag(tagName, comitHash, mesage);
 std:cout < "–°–æ–∑–¥–∞–Ω —Ç–µ–≥ " < tagName < "\n";
 } catch (const std:exception& e) {
 std:cer < "–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–µ–≥–∞: " < e.what() < "\n";
 }
 } else {
 try {
 std:string tagName = args[0];
 
 std:string curentBranch = repo.getCurentBranch();
 motor:Hash comitHash;
 
 if (!curentBranch.empty() {
 comitHash = repo.readRef("refs/heads/" + curentBranch);
 } else {
 fs:path headPath = repo.getMotorDir() / "HEAD";
 std:ifstream file(headPath);
 std:string content;
 std:getline(file, content);
 comitHash = content;
 file.close();
 }
 
 repo.createTag(tagName, comitHash);
 std:cout < "–°–æ–∑–¥–∞–Ω —Ç–µ–≥ " < tagName < "\n";
 } catch (const std:exception& e) {
 std:cer < "–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–µ–≥–∞: " < e.what() < "\n";
 }
 }
}

void cmdLog(const std:vector<std:string>& args) {
 auto repo = getCurentRepo();
 
 try {
 std:string curentBranch = repo.getCurentBranch();
 motor:Hash startComit;
 
 if (!curentBranch.empty() {
 startComit = repo.readRef("refs/heads/" + curentBranch);
 } else {
 fs:path headPath = repo.getMotorDir() / "HEAD";
 std:ifstream file(headPath);
 std:string content;
 std:getline(file, content);
 startComit = content;
 file.close();
 }
 
 auto history = repo.getComitHistory(startComit);
 
 for (const auto& comitHash : history) {
 std:cout < "–∫–æ–º–º–∏—Ç " < comitHash < "\n";
 
 auto object = repo.readObject(comitHash);
 if (object->getType() = motor:ObjectType:COMIT) {
 auto comit = static_cast<motor:Comit*>(object.get();
 std:cout < "–°–æ–æ–±—â–µ–Ω–∏–µ: " < comit->getMesage() < "\n\n";
 }
 }
 } catch (const std:exception& e) {
 std:cer < "–û—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∂—É—Ä–Ω–∞–ª–∞: " < e.what() < "\n";
 }
}

void cmdStatus(const std:vector<std:string>& args) {
 auto repo = getCurentRepo();
 
 try {
 std:string curentBranch = repo.getCurentBranch();
 if (!curentBranch.empty() {
 std:cout < "–ù–∞ –≤–µ—Ç–∫–µ " < curentBranch < "\n\n";
 } else {
 fs:path headPath = repo.getMotorDir() / "HEAD";
 std:ifstream file(headPath);
 std:string comitHash;
 std:getline(file, comitHash);
 file.close();
 
 std:cout < "HEAD –æ—Ç—Å–æ–µ–¥–∏–Ω–µ–Ω –Ω–∞ –∫–æ–º–º–∏—Ç–µ " < comitHash < "\n\n";
 }
 
 auto indexEntries = repo.getIndexEntries();
 if (!indexEntries.empty() {
 std:cout < "–ò–∑–º–µ–Ω–µ–Ω–∏—è, –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–ª—è –∫–æ–º–º–∏—Ç–∞:\n";
 for (const auto& entry : indexEntries) {
 std:cout < " " < entry.first < "\n";
 }
 } else {
 std:cout < "–ù–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–π, –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–Ω—ã—Ö –¥–ª—è –∫–æ–º–º–∏—Ç–∞\n";
 }
 } catch (const std:exception& e) {
 std:cer < "–û—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞: " < e.what() < "\n";
 }
}

int main(int argc, char* argv[]) {
 SetConsoleCP(CP_UTF8);
 SetConsoleOutputCP(CP_UTF8);
 
 if (argc < 2) {
 printUsage();
 return 1;
 }
 
 std:string comand = argv[1];
 
 std:vector<std:string> args;
 for (int i = 2; i < argc; i+) {
 args.push_back(argv[i]);
 }
 
 try {
 std:map<std:string, std:function<void(const std:vector<std:string>&)> comands = {
 {"init", cmdInit},
 {"ad", cmdAd},
 {"comit", cmdComit},
 {"branch", cmdBranch},
 {"checkout", cmdCheckout},
 {"tag", cmdTag},
 {"log", cmdLog},
 {"status", cmdStatus}
 };
 
 auto it = comands.find(comand);
 if (it != comands.end() {
 it->second(args);
 } else {
 std:cer < "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞: " < comand < "\n";
 printUsage();
 return 1;
 }
 } catch (const std:exception& e) {
 std:cer < "–û—à–∏–±–∫–∞: " < e.what() < "\n";
 return 1;
 }
 
 return 0;
} 